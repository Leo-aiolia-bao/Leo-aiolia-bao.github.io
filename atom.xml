<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Leo-aiolia-bao.github.io</id>
    <title>leo-bao</title>
    <updated>2021-02-06T13:28:12.778Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Leo-aiolia-bao.github.io"/>
    <link rel="self" href="https://Leo-aiolia-bao.github.io/atom.xml"/>
    <subtitle>科学派 | Think twice, code once</subtitle>
    <logo>https://Leo-aiolia-bao.github.io/images/avatar.png</logo>
    <icon>https://Leo-aiolia-bao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, leo-bao</rights>
    <entry>
        <title type="html"><![CDATA[Floyd 算法]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/floyd-suan-fa/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/floyd-suan-fa/">
        </link>
        <updated>2021-02-06T13:20:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="多源汇最短路问题-具有多个源点">多源汇最短路问题-具有多个源点</h1>
<h3 id="floyd算法-on3-动态规划">Floyd算法 O(n^3)-动态规划</h3>
<p>给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。</p>
<p>再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。</p>
<p>数据保证图中不存在负权回路。</p>
<h4 id="输入格式">输入格式</h4>
<p>第一行包含三个整数n，m，k</p>
<p>接下来m行，每行包含三个整数x，y，z，表示点x和点y之间存在一条有向边，边长为z。</p>
<p>接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。</p>
<h4 id="输出格式">输出格式</h4>
<p>共k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。</p>
<h4 id="数据范围">数据范围</h4>
<p>1≤n≤2001≤n≤200<br>
1≤k≤n21≤k≤n2<br>
1≤m≤200001≤m≤20000<br>
图中涉及边长绝对值均不超过10000。</p>
<h4 id="输入样例">输入样例：</h4>
<p>3 3 2<br>
1 2 1<br>
2 3 2<br>
1 3 1<br>
2 1<br>
1 3</p>
<h4 id="输出样例">输出样例：</h4>
<p>impossible<br>
1</p>
<h4 id="代码">代码：</h4>
<pre><code class="language-c">#include &lt;iostream&gt;
using namespace std;

const int N = 210, M = 2e+10, INF = 1e9;

int n, m, k, x, y, z;
int d[N][N];

void floyd() {
    for(int k = 1; k &lt;= n; k++)
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= n; j++)
            if(i == j) d[i][j] = 0;
            else d[i][j] = INF;
    while(m--) {
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        d[x][y] = min(d[x][y], z);
        //注意保存最小的边
    }
    floyd();
    while(k--) {
        cin &gt;&gt; x &gt;&gt; y;
        if(d[x][y] &gt; INF/2) puts(&quot;impossible&quot;);
        //由于有负权边存在所以约大过INF/2也很合理
        else cout &lt;&lt; d[x][y] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Leo-aiolia-bao.github.io/post-images/1612618012689.png" alt="" loading="lazy"></figure>
<h2 id="文字性复习"><strong>文字性复习</strong></h2>
<h3 id="dijkstra-朴素on2"><strong>Dijkstra-朴素O(n^2)</strong></h3>
<ol>
<li>初始化距离数组, dist[1] = 0, dist[i] = inf;</li>
<li>for n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离</li>
<li>将不在S中dist_min的点-&gt;t</li>
<li>t-&gt;S加入最短路集合</li>
<li>用t更新到其他点的距离</li>
</ol>
<h3 id="dijkstra-堆优化omlogm"><strong>Dijkstra-堆优化O(mlogm)</strong></h3>
<p>利用邻接表，优先队列<br>
在priority_queue[HTML_REMOVED], greater[HTML_REMOVED] &gt; heap;中将返回堆顶<br>
利用堆顶来更新其他点，并加入堆中类似宽搜</p>
<h3 id="bellman_fordonm"><strong>Bellman_fordO(nm)</strong></h3>
<p>注意连锁想象需要备份, struct Edge{inta,b,c} Edge[M];<br>
初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w);<br>
松弛k次，每次访问m条边</p>
<h3 id="spfa-on~onm"><strong>Spfa O(n)~O(nm)</strong></h3>
<p>利用队列优化仅加入修改过的地方<br>
for k次<br>
for 所有边利用宽搜模型去优化bellman_ford算法<br>
更新队列中当前点的所有出边</p>
<h3 id="floyd-on3"><strong>Floyd O(n^3)</strong></h3>
<p>初始化d<br>
k, i, j 去更新d</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spfa算法]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/spfa-suan-fa/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/spfa-suan-fa/">
        </link>
        <updated>2021-02-05T10:01:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="算法分析">算法分析</h3>
<h4 id="1-什么是spfa算法">1、什么是spfa算法？</h4>
<pre><code class="language-c">SPFA 算法是 Bellman-Ford算法 的队列优化算法的别称，通常用于求含负权边的单源最短路径，以及判负权环。SPFA一般情况复杂度是O(m)O(m) 最坏情况下复杂度和朴素 Bellman-Ford 相同，为O(nm)O(nm)。

bellman-ford算法操作如下：
for n次
for 所有边 a,b,w (松弛操作)
dist[b] = min(dist[b],back[a] + w)

spfa算法对第二行中所有边进行松弛操作进行了优化，原因是在bellman—ford算法中，即使该点的最短距离尚未更新过，但还是需要用尚未更新过的值去更新其他点，由此可知，该操作是不必要的，我们只需要找到更新过的值去更新其他点即可。
</code></pre>
<h4 id="2-spfa算法步骤">2、spfa算法步骤</h4>
<pre><code class="language-c">queue &lt;– 1
while queue 不为空
 (1) t &lt;– 队头
 queue.pop()
 (2)用 t 更新所有出边 t –&gt; b，权值为w
 queue &lt;– b (若该点被更新过，则拿该点更新其他点)

时间复杂度 一般：O(m)O(m) 最坏：O(nm)O(nm)
n为点数，m为边数
</code></pre>
<h4 id="3-spfa也能解决权值为正的图的最短距离问题且一般情况下比dijkstra算法还好">3、spfa也能解决权值为正的图的最短距离问题，且一般情况下比Dijkstra算法还好</h4>
<h3 id="代码及注释">代码及注释</h3>
<pre><code class="language-c">
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;

const int N=1e5+10;

#define fi first
#define se second

typedef pair&lt;int,int&gt; PII;//到源点的距离，下标号

int h[N],e[N],w[N],ne[N],idx=0;
int dist[N];//各点到源点的距离
bool st[N];
int n,m;
void add(int a,int b,int c){
    e[idx]=b;w[idx]=c;ne[idx]=h[a];h[a]=idx++;
}

int spfa(){
    queue&lt;PII&gt; q;
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    q.push({0,1});
    st[1]=true;
    while(q.size()){
        PII p=q.front();
        q.pop();
        int t=p.se;
        st[t]=false;//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队
        for(int i=h[t];i!=-1;i=ne[i]){
            int j=e[i];
            if(dist[j]&gt;dist[t]+w[i]){
                dist[j]=dist[t]+w[i];
                if(!st[j]){//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率
                    st[j]=true;
                    q.push({dist[j],j});
                }
            }
        }
    }
    if(dist[n]==0x3f3f3f3f) return -1;
    else return dist[n];
}

int main(){
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    memset(h,-1,sizeof h);
    while(m--){
        int a,b,c;
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        add(a,b,c);
    }
    int res=spfa();
    if(res==-1) puts(&quot;impossible&quot;);
    else printf(&quot;%d&quot;,res);

    return 0;
}

</code></pre>
<h3 id="算法分析2">算法分析2</h3>
<p>使用spfa算法解决是否存在负环问题</p>
<p>求负环的常用方法，基于<code>SPFA</code>，一般都用方法 2（该题也是用方法 2）：</p>
<ul>
<li>方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环</li>
<li>方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环</li>
</ul>
<p>cnt数组表示到达当前这个点最短路的边数，如果cnt[x]&gt;=n,说明至少经过了n条边，即n+1个点，由抽屉原理可知显然有两个点重复，即存在负环</p>
<p>_<strong>yls的原话</strong><br>
每次做一遍<code>spfa()</code>一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：<br>
在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为<code>0</code>的有向边。那么原图有负环等价于新图有负环。此时在新图上做<code>spfa</code>，将虚拟源点加入队列中。然后进行<code>spfa</code>的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次<code>spfa</code>可以找到负环，等价于新图有负环，等价于原图有负环。得证。</p>
<ul>
<li>
<p>1、dist[x] 记录虚拟源点到x的最短距离</p>
</li>
<li>
<p>2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] &gt;= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用</p>
</li>
<li>
<p>3、若dist[j] &gt; dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步</p>
</li>
</ul>
<h4 id="注意该题是判断是否存在负环并非判断是否存在从1开始的负环因此需要将所有的点都加入队列中更新周围的点">注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</h4>
<pre><code class="language-c">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;
const int N = 100010;

int n,m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N], cnt[N];  // cnt
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
    
}

int spfa()
{
    // memset(dist, 0x3f, sizeof dist);
    // dist[1]= 0;
    
    queue &lt;int&gt; q;
    for(int i = 1 ; i&lt;=n; i++)
    {
        st[i] = true;
        q.push(i);
    }
    
    // q.push(1);
    // st[1] = true;
    
    while(q.size())
    {
        int t = q.front();
        q.pop();
        
        st[t] = false;
        //更新t的所有邻边
        for(int i = h[t]; i!=-1; i = ne[i])
        {
            int j = e[i];
            if(dist[j] &gt; dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i]; 
                cnt[j] = cnt[t] + 1;  // 1
                
                if(cnt[j] &gt;= n) return true;  //2
                if(!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}

int main()
{
    scanf(&quot;%d%d&quot;,&amp;n, &amp;m);
    
    memset(h, -1, sizeof h);
    
    while(m --)
    {
        int a, b, c;
        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
        add(a, b, c);
    }
    
    if(spfa()) puts(&quot;Yes&quot;);
    else puts(&quot;No&quot;);
    
    
    
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图论]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/tu-lun/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/tu-lun/">
        </link>
        <updated>2021-02-05T09:30:16.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Leo-aiolia-bao.github.io/post-images/1612517738961.png" alt="" loading="lazy"></figure>
<p>正权图<br>
负权图<br>
都可用SPFA 算法 一般O(m), 最坏O(mn)<br>
比dijkstra 速度快<br>
可能会卡掉 很小可能，就是时间复杂度最坏时</p>
<p>算法： 思维 思路    写清笔记 证明<br>
代码熟练度</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bellman_ford算法]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/bellman_ford-suan-fa/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/bellman_ford-suan-fa/">
        </link>
        <updated>2021-02-05T08:40:35.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="一-前导-算法分析">(一) 前导 算法分析</h3>
<p>1、问题：为什么Dijkstra不能使用在含负权的图中？（在强大的网友指点下已进行修改）</p>
<p>正确的分析<br>
Dijkstra算法的3个步骤</p>
<pre><code>1. 找到当前未标识的且离源点最近的点t
2. 对t号点点进行标识
3. 用t号点更新其他点的距离
</code></pre>
<p>反例</p>
<figure data-type="image" tabindex="1"><img src="https://Leo-aiolia-bao.github.io/post-images/1612514547588.png" alt="例子" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<h3 id="一-前导-算法分析">(一) 前导 算法分析</h3>
<p>1、问题：为什么Dijkstra不能使用在含负权的图中？（在强大的网友指点下已进行修改）</p>
<p>正确的分析<br>
Dijkstra算法的3个步骤</p>
<pre><code>1. 找到当前未标识的且离源点最近的点t
2. 对t号点点进行标识
3. 用t号点更新其他点的距离
</code></pre>
<p>反例</p>
<figure data-type="image" tabindex="1"><img src="https://Leo-aiolia-bao.github.io/post-images/1612514547588.png" alt="例子" loading="lazy"></figure>
<!-- more -->
<p><strong>结果：</strong></p>
<p>dijkstra算法在图中走出来的最短路径是<code>1 -&gt; 2 -&gt; 4 -&gt; 5</code>，算出 1 号点到 5 号点的最短距离是<code>2 + 2 + 1 = 5</code>，然而还存在一条路径是<code>1 -&gt; 3 -&gt; 4 -&gt; 5</code>，该路径的长度是<code>5 + (-2) + 1 = 4</code>，因此 <code>dijkstra</code> 算法失效<br>
(dijkstra不能解决负权边是因为 dijkstra要求每个点被确定后st[j] = true，dist[j]就是最短距离了，之后就不能再被更新了（一锤子买卖），而如果有负权边的话，那已经确定的点的dist[j]不一定是最短了)</p>
<h4 id="详解代码如下">详解代码如下：</h4>
<pre><code class="language-c">int dijkstra()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;

    for(int i=0;i&lt;n-1;i++)
    {
        cout&lt;&lt;&quot;第&quot;&lt;&lt;(i+1)&lt;&lt;&quot;次循环&quot;&lt;&lt;endl;
        int t=-1;
        cout&lt;&lt;&quot;还没开始找未被标记的数之前t的值为：&quot;&lt;&lt;t&lt;&lt;endl;
        int m=1;
        for(int j=1;j&lt;=n;j++)
        {    
            if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))
            {
                cout&lt;&lt;&quot;循环内第&quot;&lt;&lt;m&lt;&lt;&quot;次找到符合条件的j是：&quot;&lt;&lt;j&lt;&lt;endl;
                m++;
                t=j;
            }
        }        
        cout&lt;&lt;&quot;被标记的数t的值为：&quot;&lt;&lt;t&lt;&lt;endl;

        st[t]=true;

        for(int j=1;j&lt;=n;j++)
            dist[j] = min(dist[j],dist[t]+g[t][j]);

        cout&lt;&lt;&quot;第&quot;&lt;&lt;(i+1)&lt;&lt;&quot;次循环后dist数组的更新情况：&quot;&lt;&lt;endl;
        for(int j=1;j&lt;=n;j++)
        {
            cout&lt;&lt;&quot;dist[&quot;&lt;&lt;j&lt;&lt;&quot;]距离为:&quot;&lt;&lt;dist[j]&lt;&lt;&quot;, &quot;;
        }
        puts(&quot;&quot;);
        puts(&quot;---------------------------------&quot;);
    }

    if(dist[n]==0x3f3f3f3f) return -1;
    else return dist[n];
}
输出：

第1次循环
还没开始找未被标记的数之前t的值为：-1
循环内第1次找到符合条件的j是：1
被标记的数t的值为：1
第1次循环后dist数组的更新情况：
dist[1]距离为:0, dist[2]距离为:2, dist[3]距离为:5, dist[4]距离为:1061109567, dist[5]距离为:1061109567, 
---------------------------------
第2次循环
还没开始找未被标记的数之前t的值为：-1
循环内第1次找到符合条件的j是：2
被标记的数t的值为：2
第2次循环后dist数组的更新情况：
dist[1]距离为:0, dist[2]距离为:2, dist[3]距离为:5, dist[4]距离为:4, dist[5]距离为:1061109567, 
---------------------------------
第3次循环
还没开始找未被标记的数之前t的值为：-1
循环内第1次找到符合条件的j是：3
循环内第2次找到符合条件的j是：4
被标记的数t的值为：4
第3次循环后dist数组的更新情况：
dist[1]距离为:0, dist[2]距离为:2, dist[3]距离为:5, dist[4]距离为:4, dist[5]距离为:5, 
---------------------------------
第4次循环
还没开始找未被标记的数之前t的值为：-1
循环内第1次找到符合条件的j是：3
被标记的数t的值为：3
第4次循环后dist数组的更新情况：
dist[1]距离为:0, dist[2]距离为:2, dist[3]距离为:5, dist[4]距离为:3, dist[5]距离为:5, 
---------------------------------
最短路径结果是：5

</code></pre>
<h3 id="二-什么是bellman-ford算法">(二) 什么是bellman - ford算法？</h3>
<p><code>Bellman - ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。</code><br>
(通俗的来讲就是：假设 1 号点到 n 号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环 n-1 次操作，若图中不存在负环，则 1 号点一定会到达 n 号点，若图中存在负环，则在 n-1 次松弛后一定还会更新)</p>
<p>3、bellman - ford算法的具体步骤</p>
<pre><code class="language-c">for n次
for 所有边 a,b,w (松弛操作)
dist[b] = min(dist[b],back[a] + w)
</code></pre>
<p>注意：back[] 数组是上一次迭代后 dist[] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点</p>
<p>4、在下面代码中，是否能到达n号点的判断中需要进行if(dist[n] &gt; INF/2)判断，而并非是if(dist[n] == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，dist[n]大于某个与INF相同数量级的数即可<br>
5、bellman - ford算法擅长解决有边数限制的最短路问题<br>
时间复杂度 O(nm)O(nm)<br>
其中n为点数，m为边数</p>
<pre><code class="language-c">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;

const int N=510,M=10010;

struct Edge{
    int a;
    int b;
    int w;
}e[M];//把每个边保存下来即可
int dist[N];
int back[N];//备份数组放置串联
int n,m,k;//k代表最短路径最多包涵k条边

int bellman_ford(){
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    for(int i=0;i&lt;k;i++){//k次循环
        memcpy(back,dist,sizeof dist);
        for(int j=0;j&lt;m;j++){//遍历所有边
            int a=e[j].a,b=e[j].b,w=e[j].w;
            dist[b]=min(dist[b],back[a]+w);//使用backup:避免给a更新后立马更新b,这样b一次性最短路径就多了两条边出来
        }

    }
    if(dist[n]&gt;0x3f3f3f3f/2) return -1;
    else return dist[n];

}

int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
    for(int i=0;i&lt;m;i++){
        int a,b,w;
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);
        e[i]={a,b,w};
    }
    int res=bellman_ford();
    if(res==-1) puts(&quot;impossible&quot;);
    else cout&lt;&lt;res;


    return 0;
}
</code></pre>
<h2 id="需要注意的是"><strong>需要注意的是</strong></h2>
<ol>
<li>需要把dist数组进行一个备份，这样防止每次更新的时候出现串联；</li>
<li>由于存在负权边，因此return -1的条件就要改成dist[n]&gt;0x3f3f3f3f/2;</li>
<li>上面所谓的n次遍历的实际含义是当前的最短路径最多有n-1条边，这也就解释了为啥要i遍历到n的时候退出循环了，因为只有n个点,最短路径无环最多就存在n-1条边。</li>
<li>这里无需对重边和自环做单独的处理：<br>
<code>1] 重边：由于遍历了所有的边，总会遍历到较短的那一条; 2] 自环: 有自环就有自环啊，反正又不会死循环;</code></li>
<li>令人愉悦的是，该算法无非就是循环n次然后遍历所有的边，因此不需要做什么特别的存储，只要把所有的边的信息存下来能够遍历就行;<br>
6）bellman_ford算法可以存在负权回路，因为它求得的最短路是有限制的，是限制了边数的，这样不会永久的走下去，会得到一个解；<br>
7)SPFA算法各方面优于该算法，但是在碰到限制了最短路径上边的长度时就只能用bellman_ford了，此时直接把n重循环改成k次循环即可</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[朴素的Dijkstra算法]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/po-su-de-dijkstra-suan-fa/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/po-su-de-dijkstra-suan-fa/">
        </link>
        <updated>2021-02-04T08:43:10.000Z</updated>
        <content type="html"><![CDATA[<pre><code>日期：2021年2月4日
时间：16点53分
😅🏀🏀🕔
</code></pre>
<p><strong>题目</strong></p>
<pre><code class="language-c">给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

输入格式
第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

输出格式
输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出-1。

数据范围
1≤n≤500,
1≤m≤105,
图中涉及边长均不超过10000。

输入样例：
3 3
1 2 2
2 3 1
1 3 4
输出样例：
3

</code></pre>
<p><strong>以下为完整代码</strong></p>
<pre><code class="language-c">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;

const int N=510;

int g[N][N];    //为稠密阵所以用邻接矩阵存储
int dist[N];    //用于记录每一个点距离第一个点的距离
bool st[N];     //用于记录该点的最短距离是否已经确定

int n,m;

int Dijkstra()
{
    memset(dist, 0x3f,sizeof dist);     //初始化距离  0x3f代表无限大

    dist[1]=0;  //第一个点到自身的距离为0

    for(int i=0;i&lt;n;i++)      //有n个点所以要进行n次 迭代
    {
        int t=-1;       //t存储当前访问的点

        for(int j=1;j&lt;=n;j++)   //这里的j代表的是从1号点开始
            if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))     
                t=j;

        st[t]=true;   

        for(int j=1;j&lt;=n;j++)           //依次更新每个点所到相邻的点路径值
            dist[j]=min(dist[j],dist[t]+g[t][j]);
    }

    if(dist[n]==0x3f3f3f3f) return -1;  //如果第n个点路径为无穷大即不存在最低路径
    return dist[n];
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;

    memset(g,0x3f,sizeof g);    //初始化图 因为是求最短路径
                                //所以每个点初始为无限大

    while(m--)
    {
        int x,y,z;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        g[x][y]=min(g[x][y],z);     //如果发生重边的情况则保留最短的一条边
    }

    cout&lt;&lt;Dijkstra()&lt;&lt;endl;
    return 0;
}


</code></pre>
<p>**思路笔记 **<br>
有之前宽搜和深搜的基础  就感觉思路特别清晰了</p>
<p>最近复习了下<code>Dijkstra</code> 发现之前的理解还是有些不太到位<br>
所以更新了一下 希望能帮助一起学算法的小伙伴理清思路</p>
<p><code>Dijkstra</code>  的整体思路比较清晰<br>
即进行<code>n（n为n的个数）</code>次迭代去确定每个点到起点的最小值 最后输出的终点的即为我们要找的最短路的距离</p>
<p>所以按照这个思路除了存储图外我们还需要存储两个量</p>
<p><code>dist[n]</code>//用于存储每个点到起点的最短距离<br>
<code>st[n]</code>  //用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新</p>
<p>每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点<br>
（至于为什么是这样那么这就涉及到<code>Dijkstra算法</code>的具体数学证明了 有兴趣的同学可以百度一下）</p>
<pre><code class="language-c">int t=-1;       //将t设置为-1 因为Dijkstra算法适用于不存在负权边的图
for(int j=1;j&lt;=n;j++)
{
    if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j])    //该步骤即寻找还未确定最短路的点中路径最短的点
        t=j;
}
</code></pre>
<p>通过上述操作当前我们的t代表就是剩余未确定最短路的点中 路径最短的点<br>
而与此同时该点的最短路径也已经确定我们将该点标记</p>
<p><code>st[t]=true;</code></p>
<p>然后用这个去更新其余未确定点的最短距离</p>
<p><code>for(int j=1;j&lt;=n;j++)</code><br>
<code>dist[j]=min(dist[j],dist[t]+g[t][j]);</code><br>
//这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离<br>
//但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响<br>
//当然你也可以在循环判断条件里加上<code>if(!st[i])</code><br>
//这里j从1开始只是为了代码的简洁</p>
<p>进行n次迭代后最后就可以确定每个点的最短距离<br>
然后再根据题意输出相应的 要求的最短距离</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[五分钟搭建自己的博客-github+gridea搭建博客和绑定域名]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/wu-fen-zhong-da-jian-zi-ji-de-bo-ke/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/wu-fen-zhong-da-jian-zi-ji-de-bo-ke/">
        </link>
        <updated>2021-02-04T08:27:00.000Z</updated>
        <content type="html"><![CDATA[<p>几个教程如下：按部就班操作即可</p>
<p><a href="https://www.luogu.com.cn/blog/ak-ioi/building-a-blog/">git 及 Gridea 教程</a></p>
<p><a href="https://gridea.dev/gridea-start/">Gridea官网教程</a></p>
<p><a href="%5BGridea%E5%AE%98%E7%BD%91%E6%95%99%E7%A8%8B%5D(https://gridea.dev/gridea-start/)">不错的csdn教程</a></p>
<p>我踩得坑： <strong>域名</strong>和<strong>仓库</strong>名字 不一致，导致折腾半天找不到自己的博客网站</p>
<p>如域名：https://getridea.github.io<br>
仓库：getgridea.github.io</p>
<p>这样即可 ，<br>
而下面不可</p>
<p>如域名：https://getridea.github.io<br>
仓库：myblog.github.io</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/markdown-yu-fa/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/markdown-yu-fa/">
        </link>
        <updated>2021-02-04T04:12:11.000Z</updated>
        <content type="html"><![CDATA[<p>Markdown 的目标是实现「易读易写」，成为一种适用于网络的书写语言。因此洛谷使用 Markdown 发布内容。</p>
<p>请仔细阅读下列文档，如果没有按照要求正确使用格式，将可能无法发出讨论，或者被删除。</p>
<p>段落和换行<br>
一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行。普通的 Markdown 段落不可以用空格或制表符来缩进。</p>
<p>空行：一行之内只包含回车换行、空格、制表符。</p>
<p>标题<br>
Markdown 的标题是在行首插入 1 到 6 个 # ，#和标题文字之间使用一个或多个空格，对应到标题 1 到 6 级。</p>
<p>例如：</p>
<h1 id="这是-h1">这是 H1</h1>
<h2 id="这是-h2">这是 H2</h2>
<h3 id="这是-h3">这是 H3</h3>
<p>显示的效果如下：</p>
<p>#这是 H1<br>
##这是 H2<br>
###这是 H3<br>
不要全文使用标题，或者用标题强调特别多的文字。这会让读者觉得困扰。</p>
<p>强调<br>
Markdown 使用星号（*）和底线（<em>）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <em> 标签包围（即斜体），用两个 * 或</em> 包起来的话，则会被转成 <strong>（即粗体）。</p>
<p>例如：</p>
<p><em>单引号斜体</em></p>
<p><em>单下划线斜体</em></p>
<p><strong>双引号加粗</strong></p>
<p><strong>双下划线加粗</strong></p>
<p><s>删除线</s><br>
显示的效果如下：</p>
<p>单引号斜体</p>
<p>单下划线斜体</p>
<p>双引号加粗</p>
<p>双下划线加粗</p>
<p>删除线</p>
<p>但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线（\）（参见下面的“反斜杠”部分）。</p>
<p>例如：</p>
<p>*使用反斜线开头的*被当做是普通的字符*<br>
显示的效果如下：</p>
<p><em>使用反斜线开头的</em>被当做是普通的字符*</p>
<p>代码块<br>
如果要发送代码，但没有按照下面的方式进行格式化，将不能发送成功。</p>
<p>大段代码<br>
Markdown建立代码块的方法：将<code>置于这段代码的首行和末行，独立成一行。第一行的</code>后面可以加上语言名称，例如 cpp、java、c、pascal 等（不要写成 c++）。</p>
<p>例如：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
</code></pre>
<p>显示成</p>
<p>#include<iostream><br>
小段代码<br>
需要引用代码时，如果引用的语句只有一段，不分行，可以用`将语句包起来。</p>
<p>注：如果你真的要打<code>这个字符的话，可以仿照和*这个字符一样的处理方式，在</code>前加一个反斜杠。</p>
<p>区块引用<br>
Markdown 标记区块引用的方法是在行的最前面加 &gt; ，也可以只在整个段落的第一行最前面加上 &gt;，区块引用内部可以嵌套，只要根据层次加上不同数量的 &gt;即可，引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。</p>
<p>例如:</p>
<blockquote>
<p>Markdown 标记区块引用的方法是在行的最前面加&gt;</p>
<p>也可以只在整个段落的第一行最前面加上 &gt;</p>
<blockquote>
<p>区块引用内部可以嵌套，只要根据层次加上不同数量的 &gt;即可.</p>
<p><em>我是内部嵌套区块，我可以使用其他 Markdown 语法哦</em></p>
<h3 id="我是引用区块内使用标题3语法">我是引用区块内使用标题3语法</h3>
<pre><code class="language-java">     //在引用区块内可以加入代码块
     import java.net.URL;
     import java.util.Arrays;
     import java.util.Date;
     import java.util.Set;
</code></pre>
</blockquote>
</blockquote>
<p>显示的效果如下：</p>
<p>Markdown 标记区块引用的方法是在行的最前面加&gt;</p>
<p>也可以只在整个段落的第一行最前面加上 &gt;</p>
<p>区块引用内部可以嵌套，只要根据层次加上不同数量的 &gt;即可.</p>
<p>我是内部嵌套区块，我可以使用其他 Markdown 语法哦</p>
<p>我是引用区块内使用标题3语法<br>
//在引用区块内可以加入代码块<br>
import java.net.URL;<br>
import java.util.Arrays;<br>
import java.util.Date;<br>
import java.util.Set;<br>
列表<br>
Markdown 支持有序列表和无序列表，无序列表使用星号、加号或是减号作为列表标记，有序列表则使用数字接着一个英文句点。两种列表方式格式都是：列表标记+空格+列表项，即列表项目标记通常是放在最左边，也可以缩进最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>(1)无序列表<br>
星号、加号或是减号三种列表方式效果等同。</p>
<p>例如：</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue<br>
它们的显示效果均为：</li>
</ul>
<p>Red<br>
Green<br>
Blue<br>
(2)有序列表<br>
有序列表则使用数字接着一个英文句点。</p>
<p>例如：</p>
<ol>
<li>Red</li>
<li>Green</li>
<li>Blue<br>
显示效果为：</li>
</ol>
<p>Red<br>
Green<br>
Blue<br>
链接<br>
在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<p>这是 行内式链接标题 内联方式.</p>
<p><a href="http://www.luogu.org/">行内式链接标题</a><br>
图片<br>
Markdown 使用一种和链接很相似的语法来标记图片</p>
<p>行内式的图片语法如下：</p>
<figure data-type="image" tabindex="1"><img src="%E5%9B%BE%E7%89%87%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E6%88%96%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84" alt="图片下方文字" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="%E5%9B%BE%E7%89%87%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E6%88%96%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84" alt="图片下方文字" title="可选标题" loading="lazy"></figure>
<p>详细叙述如下：一个惊叹号!，接着一个方括号，里面放上图片的替代文字（这些文字将在图片加载失败的时候显示），接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 'title' 文字。</p>
<p>例如：</p>
<p><img src="https://cdn.class.luogu.com.cn/fe/logo-full.png?27925f707b34b1472e135b1a2dd848e5" alt="logo" loading="lazy"><br>
将会显示图片：</p>
<p>logo</p>
<p>自动链接<br>
Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<p><a href="https://www.luogu.com.cn/">https://www.luogu.com.cn/</a><br>
显示效果为：</p>
<p>https://www.luogu.com.cn/</p>
<p>分隔线<br>
可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他内容。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>显示的效果如下：</p>
<p>反斜杠<br>
Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用<em>标签），你可以在星号的前面加上反斜杠。</p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号（加上反斜杠后，这些符号都会以原来的方式显示）：</p>
<p>\   反斜线<br>
`   反引号</p>
<ul>
<li>星号<br>
_   底线<br>
{}  花括号<br>
[]  方括号<br>
()  括弧</li>
</ul>
<h1 id="井字号">井字号</h1>
<ul>
<li>加号</li>
</ul>
<ul>
<li>减号<br>
.   英文句点<br>
!   惊叹号</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://Leo-aiolia-bao.github.io/post/hello-gridea/</id>
        <link href="https://Leo-aiolia-bao.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>